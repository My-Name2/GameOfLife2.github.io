<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Conway's Game of Life with Three.js</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.z = 50;
    controls.update();

    const cellSize = 2; // Cube size for each cell
    const gridSize = 20; // X and Y size of the grid
    const layers = 10; // Z size of the grid (depth)

    // Create a 3D array (grid)
    let grid = create3DGrid(gridSize, gridSize, layers);

    // Create a 3D grid to track cube objects
    let cubes = create3DCubeGrid(gridSize, gridSize, layers);

    // Create a 3D grid (X, Y, Z) with all cells dead initially
    function create3DGrid(xSize, ySize, zSize) {
      return Array.from({ length: xSize }, () =>
        Array.from({ length: ySize }, () =>
          Array.from({ length: zSize }, () => 0)
        )
      );
    }

    // Create a cube for each alive cell
    function create3DCubeGrid(xSize, ySize, zSize) {
      let cubes = [];
      for (let x = 0; x < xSize; x++) {
        cubes[x] = [];
        for (let y = 0; y < ySize; y++) {
          cubes[x][y] = [];
          for (let z = 0; z < zSize; z++) {
            const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, visible: false }); // Invisible cubes for dead cells
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x * (cellSize + 0.1), y * (cellSize + 0.1), z * (cellSize + 0.1)); // Position cubes
            scene.add(cube);
            cubes[x][y][z] = cube;
          }
        }
      }
      return cubes;
    }

    // Generate a random color for neon effect
    function getRandomNeonColor() {
      const neonColors = [0x39FF14, 0xFF073A, 0xFF61F6, 0x0FF0FC, 0xFFFF33, 0xFFAA1D, 0xB200ED, 0x7FFF00];
      return neonColors[Math.floor(Math.random() * neonColors.length)];
    }

    // Randomly fill the grid with alive cells (and update the cubes)
    function randomFillGrid() {
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          for (let z = 0; z < layers; z++) {
            const isAlive = Math.random() > 0.8 ? 1 : 0;
            grid[x][y][z] = isAlive;
            cubes[x][y][z].material.visible = isAlive ? true : false;
            if (isAlive) {
              cubes[x][y][z].material.color.setHex(getRandomNeonColor());
            }
          }
        }
      }
    }

    // Animate the scene and render the 3D cubes
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Initial random fill and animation start
    randomFillGrid();
    animate();

    // Resize renderer on window resize
    window.addEventListener('resize', function () {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
